#!/usr/bin/env node

/**
 * Dictionary Splitter
 *
 * Splits monolithic dictionary files (en.json, it.json) into smaller chunks
 * organized by section for better performance and caching.
 *
 * Usage: node scripts/split-dictionaries.js
 */

const fs = require('fs');
const path = require('path');

// Configuration
const DICTIONARIES_DIR = path.join(__dirname, '../lib/i18n/dictionaries');
const LOCALES = ['en', 'it'];

// Define which top-level keys go into which section
const SECTION_MAPPING = {
  common: ['common'],
  home: ['home'],
  tools: ['tools'],
  categories: ['categories'],
  footer: ['footer'],
  seo: ['seo'],
};

/**
 * Read and parse a dictionary file
 */
function readDictionary(locale) {
  const filePath = path.join(DICTIONARIES_DIR, `${locale}.json`);

  if (!fs.existsSync(filePath)) {
    throw new Error(`Dictionary file not found: ${filePath}`);
  }

  const content = fs.readFileSync(filePath, 'utf8');
  return JSON.parse(content);
}

/**
 * Create section directory if it doesn't exist
 */
function ensureSectionDir(locale) {
  const sectionDir = path.join(DICTIONARIES_DIR, locale);

  if (!fs.existsSync(sectionDir)) {
    fs.mkdirSync(sectionDir, { recursive: true });
    console.log(`‚úÖ Created directory: ${sectionDir}`);
  }

  return sectionDir;
}

/**
 * Extract section data from full dictionary
 */
function extractSection(dictionary, sectionKeys) {
  const sectionData = {};

  sectionKeys.forEach((key) => {
    if (dictionary[key]) {
      sectionData[key] = dictionary[key];
    } else {
      console.warn(`‚ö†Ô∏è  Key "${key}" not found in dictionary`);
    }
  });

  return sectionData;
}

/**
 * Write section file
 */
function writeSectionFile(locale, sectionName, data) {
  const sectionDir = path.join(DICTIONARIES_DIR, locale);
  const filePath = path.join(sectionDir, `${sectionName}.json`);

  // Pretty print JSON with 2 space indentation
  const jsonContent = JSON.stringify(data, null, 2);

  fs.writeFileSync(filePath, jsonContent, 'utf8');

  // Calculate file size
  const stats = fs.statSync(filePath);
  const sizeKB = (stats.size / 1024).toFixed(2);

  console.log(`‚úÖ Created: ${locale}/${sectionName}.json (${sizeKB} KB)`);

  return stats.size;
}

/**
 * Create index file for easy importing
 */
function createIndexFile(locale) {
  const indexPath = path.join(DICTIONARIES_DIR, locale, 'index.ts');

  const sections = Object.keys(SECTION_MAPPING);

  const indexContent = `/**
 * Dictionary sections for ${locale.toUpperCase()} locale
 * Auto-generated by scripts/split-dictionaries.js
 */

${sections
  .map(
    (section) => `export { default as ${section} } from './${section}.json';`
  )
  .join('\n')}

/**
 * Load all sections (for backward compatibility)
 */
export async function loadAll() {
  const [${sections.join(', ')}] = await Promise.all([
    ${sections.map((s) => `import('./${s}.json').then(m => m.default)`).join(',\n    ')}
  ]);

  return {
    ${sections.map((s) => `...${s}`).join(',\n    ')}
  };
}
`;

  fs.writeFileSync(indexPath, indexContent, 'utf8');
  console.log(`‚úÖ Created: ${locale}/index.ts`);
}

/**
 * Main splitting function
 */
function splitDictionary(locale) {
  console.log(`\nüì¶ Processing ${locale.toUpperCase()} dictionary...`);

  // Read monolithic dictionary
  const dictionary = readDictionary(locale);
  const originalSize = JSON.stringify(dictionary).length;

  // Ensure section directory exists
  ensureSectionDir(locale);

  let totalSplitSize = 0;

  // Split into sections
  Object.entries(SECTION_MAPPING).forEach(([sectionName, keys]) => {
    const sectionData = extractSection(dictionary, keys);
    const size = writeSectionFile(locale, sectionName, sectionData);
    totalSplitSize += size;
  });

  // Create index file
  createIndexFile(locale);

  // Calculate savings
  const originalKB = (originalSize / 1024).toFixed(2);
  const splitKB = (totalSplitSize / 1024).toFixed(2);
  const savings = ((1 - totalSplitSize / originalSize) * 100).toFixed(1);

  console.log(`\nüìä ${locale.toUpperCase()} Summary:`);
  console.log(`   Original: ${originalKB} KB (monolithic)`);
  console.log(`   Split total: ${splitKB} KB`);
  console.log(
    `   Overhead: ${totalSplitSize - originalSize > 0 ? '+' : ''}${((totalSplitSize - originalSize) / 1024).toFixed(2)} KB`
  );
  console.log(
    `   Average section: ${(totalSplitSize / Object.keys(SECTION_MAPPING).length / 1024).toFixed(2)} KB`
  );
}

/**
 * Backup original files
 */
function backupOriginals() {
  console.log('\nüíæ Creating backups...');

  LOCALES.forEach((locale) => {
    const original = path.join(DICTIONARIES_DIR, `${locale}.json`);
    const backup = path.join(DICTIONARIES_DIR, `${locale}.json.backup`);

    if (fs.existsSync(original)) {
      fs.copyFileSync(original, backup);
      console.log(`‚úÖ Backed up: ${locale}.json ‚Üí ${locale}.json.backup`);
    }
  });
}

/**
 * Main execution
 */
function main() {
  console.log('üöÄ Dictionary Splitter v1.0.0');
  console.log('================================\n');

  try {
    // Backup originals first
    backupOriginals();

    // Split each locale
    LOCALES.forEach((locale) => {
      splitDictionary(locale);
    });

    console.log('\n‚ú® Dictionary splitting completed successfully!');
    console.log('\nüìÅ New structure:');
    console.log('   lib/i18n/dictionaries/');
    LOCALES.forEach((locale) => {
      console.log(`   ‚îú‚îÄ‚îÄ ${locale}/`);
      Object.keys(SECTION_MAPPING).forEach((section, idx, arr) => {
        const isLast = idx === arr.length - 1;
        console.log(`   ‚îÇ   ${isLast ? '‚îî' : '‚îú'}‚îÄ‚îÄ ${section}.json`);
      });
    });

    console.log('\nüí° Next steps:');
    console.log('   1. Update API routes to support section parameter');
    console.log('   2. Update dictionary loaders (server + client)');
    console.log('   3. Update DictionaryProvider to accept sections prop');
    console.log('   4. Test with npm run dev');
  } catch (error) {
    console.error('\n‚ùå Error:', error.message);
    process.exit(1);
  }
}

// Run if called directly
if (require.main === module) {
  main();
}

module.exports = { splitDictionary, SECTION_MAPPING };
